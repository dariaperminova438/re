# Рекурсивные и комбинаторные алгоритмы
# Перминова Дарья УИБО-09-24
# ВАРИАНТ 8. 
Реализуйте рекурсивную функцию для подсчета суммы элементов массива.

# Результаты работы программ на 3 языках
1) Python
Тест 1 - Сумма [1, 3, 5, 7, 9] = 25
Тест 2 - Сумма [10, -2, 5, -8, 3] = 8
Тест 3 - Сумма [] = 0

2) Java
Тест 1 - Сумма больших чисел = 1500
Тест 2 - Сумма с нулями = 9
Тест 3 - Сумма одного элемента = 42

3) C++
Тест 1 - Арифметическая прогрессия: 120
Тест 2 - Смешанные знаки: 24
Тест 3 - Все одинаковые: 35

# Объяснение работы алгоритма

Шаги работы алгоритма:

1. Получаем массив и начальный индекс
2. Проверяем базовый случай:
   · Если индекс ≥ длины массива
   · Возвращаем 0 (конец рекурсии)
3. Если не базовый случай:
   · Берем элемент по текущему индексу
   · Вызываем эту же функцию для следующего индекса (index + 1)
4. Складываем результаты:
   · Текущий элемент + результат рекурсивного вызова
5. Возвращаем сумму на предыдущий уровень рекурсии
6. Процесс повторяется пока не дойдем до конца массива

# Объяснение команд и функций кода (одного из трех)
Выбираю для объяснения - язык Python. Как работает этот алгоритм? 

Команда def array_sum(arr, index=0): объявляет новую функцию с именем array_sum, которая принимает два параметра: arr (массив) и index (текущая позиция в массиве). Параметр index=0 означает, что если индекс не указан при вызове, он автоматически становится равным 0.

Команда if index >= len(arr): использует функцию len() для определения длины массива и оператор >= для сравнения. Если условие истинно, это означает, что мы дошли до конца массива.

Команда return 0 выполняется только при базовом случае рекурсии - когда индекс вышел за границы массива. Это останавливает рекурсию и возвращает значение 0.

Команда return arr[index] + array_sum(arr, index + 1) является рекурсивным вызовом. Функция array_sum вызывает саму себя с увеличенным индексом. Сначала выполняется правая часть - рекурсивный вызов, который вычисляет сумму оставшихся элементов, затем к этому результату прибавляется текущий элемент arr[index], и окончательная сумма возвращается из функции.

Оценка big(O):

время - O(n), память - O(n).

Почему именно такая временная сложность? 
Сложность возникает, потому что алгоритм проходит каждый элемент массива ровно один раз, и рекурсивные вызовы создают n уровней стека вызовов, где n - количество элементов в массиве.

# Ответ на вопрос
Вопрос - номер 3: Почему наивная рекурсивная реализация чисел Фибоначчи неэффективна?

Наивная рекурсия Фибоначчи неэффективна, потому что многократно вычисляет одни и те же значения. Время работы растет экспоненциально O(2ⁿ), а не линейно.


